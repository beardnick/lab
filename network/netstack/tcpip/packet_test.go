package tcpip

import (
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestDecodePack(t *testing.T) {
	type args struct {
		data []byte
	}
	tests := []struct {
		name string
		args args
		want *IPPack
	}{
		{
			name: "only header",
			args: args{
				data: []byte{
					// ip header
					0x45, 0x00, 0x00, 0x3c,
					0x80, 0x40, 0x40, 0x00,
					0x40, 0x06, 0xa4, 0x79,
					0x0b, 0x00, 0x00, 0x01,
					0x0b, 0x00, 0x00, 0x02,
					// tcp header
					0xbb, 0xf8, 0x00, 0x50,
					0x08, 0xa8, 0x4a, 0x04,
					0x00, 0x00, 0x00, 0x00,
					0xa0, 0x02, 0xfa, 0xf0,
					0x67, 0x67, 0x00, 0x00,
					0x02, 0x04, 0x05, 0xb4,
					0x04, 0x02, 0x08, 0x0a,
					0xbf, 0xb6, 0x00, 0xfa,
					0x00, 0x00, 0x00, 0x00,
					0x01, 0x03, 0x03, 0x07,
				},
			},
			want: &IPPack{
				IPHeader: &IPHeader{
					Version:        4,
					HeaderLength:   20,
					TypeOfService:  0,
					TotalLength:    0x003c,
					Identification: 0x8040,
					Flags:          2,
					FragmentOffset: 0,
					TimeToLive:     0x40,
					Protocol:       0x06,
					HeaderChecksum: 0xa479,
					SrcIP:          net.IP{0x0b, 0x00, 0x00, 0x01},
					DstIP:          net.IP{0x0b, 0x00, 0x00, 0x02},
					Options:        []byte{},
				},
				Payload: &TcpPack{
					TcpHeader: &TcpHeader{
						SrcPort:        0xbbf8,
						DstPort:        0x0050,
						SequenceNumber: 0x08a84a04,
						AckNumber:      0x00000000,
						DataOffset:     40,
						Reserved:       0x0,
						Flags:          0x02,
						WindowSize:     0xfaf0,
						Checksum:       0x6767,
						UrgentPointer:  0x0000,
						Options: []byte{
							0x02, 0x04, 0x05, 0xb4,
							0x04, 0x02, 0x08, 0x0a,
							0xbf, 0xb6, 0x00, 0xfa,
							0x00, 0x00, 0x00, 0x00,
							0x01, 0x03, 0x03, 0x07,
						},
					},
					Payload: &RawPack{data: []byte{}},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pack := NewIPPack(NewTcpPack(&RawPack{}))
			got, err := pack.Decode(tt.args.data)
			assert.Nil(t, err)
			assert.Equal(t, got, tt.want)
		})
	}
}

func TestEncodePack(t *testing.T) {
	type args struct {
		pack *IPPack
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "calculate checksum",
			args: args{
				pack: &IPPack{
					IPHeader: &IPHeader{
						Version:        4,
						HeaderLength:   20,
						TypeOfService:  0,
						TotalLength:    0x003c,
						Identification: 0x8040,
						Flags:          2,
						FragmentOffset: 0,
						TimeToLive:     0x40,
						Protocol:       0x06,
						HeaderChecksum: 0xa479,
						SrcIP:          net.IP{0x0b, 0x00, 0x00, 0x01},
						DstIP:          net.IP{0x0b, 0x00, 0x00, 0x02},
						Options:        []byte{},
					},
					Payload: &TcpPack{
						PseudoHeader: &PseudoHeader{
							SrcIP: []byte{0x0b, 0x00, 0x00, 0x01},
							DstIP: []byte{0x0b, 0x00, 0x00, 0x02},
						},
						TcpHeader: &TcpHeader{
							SrcPort:        0xbbf8,
							DstPort:        0x0050,
							SequenceNumber: 0x08a84a04,
							AckNumber:      0x00000000,
							DataOffset:     0,
							Reserved:       0x0,
							Flags:          0x02,
							WindowSize:     0xfaf0,
							Checksum:       0,
							UrgentPointer:  0x0000,
							Options: []byte{
								0x02, 0x04, 0x05, 0xb4,
								0x04, 0x02, 0x08, 0x0a,
								0xbf, 0xb6, 0x00, 0xfa,
								0x00, 0x00, 0x00, 0x00,
								0x01, 0x03, 0x03, 0x07,
							},
						},
						Payload: &RawPack{data: []byte{}},
					},
				},
			},
			want: []byte{
				// ip header
				0x45, 0x00, 0x00, 0x3c,
				0x80, 0x40, 0x40, 0x00,
				0x40, 0x06, 0xa4, 0x79,
				0x0b, 0x00, 0x00, 0x01,
				0x0b, 0x00, 0x00, 0x02,
				// tcp header
				0xbb, 0xf8, 0x00, 0x50,
				0x08, 0xa8, 0x4a, 0x04,
				0x00, 0x00, 0x00, 0x00,
				0xa0, 0x02, 0xfa, 0xf0,
				0x67, 0x67, 0x00, 0x00,
				0x02, 0x04, 0x05, 0xb4,
				0x04, 0x02, 0x08, 0x0a,
				0xbf, 0xb6, 0x00, 0xfa,
				0x00, 0x00, 0x00, 0x00,
				0x01, 0x03, 0x03, 0x07,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.args.pack.Encode()
			assert.Nil(t, err)
			assert.Equal(t, got, tt.want)
		})
	}
}

func TestEncodeChecksum(t *testing.T) {
	type args struct {
		pack *IPPack
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "no options",
			args: args{
				pack: &IPPack{
					IPHeader: &IPHeader{
						Version:       4,
						HeaderLength:  20,
						TypeOfService: 0,
						// TotalLength:    0x003c,
						TotalLength:    0,
						Identification: 0x8040,
						Flags:          2,
						FragmentOffset: 0,
						TimeToLive:     0x40,
						Protocol:       0x06,
						// HeaderChecksum: 0xa479,
						HeaderChecksum: 0,
						SrcIP:          net.IP{0x0b, 0x00, 0x00, 0x01},
						DstIP:          net.IP{0x0b, 0x00, 0x00, 0x02},
						Options:        []byte{},
					},
					Payload: &TcpPack{
						PseudoHeader: &PseudoHeader{
							SrcIP: []byte{0x0b, 0x00, 0x00, 0x01},
							DstIP: []byte{0x0b, 0x00, 0x00, 0x02},
						},
						TcpHeader: &TcpHeader{
							SrcPort:        0xbbf8,
							DstPort:        0x0050,
							SequenceNumber: 0x08a84a04,
							AckNumber:      0x00000000,
							DataOffset:     40,
							Reserved:       0x0,
							Flags:          0x02,
							WindowSize:     0xfaf0,
							// Checksum:       0x6767,
							Checksum:      0,
							UrgentPointer: 0x0000,
							Options: []byte{
								0x02, 0x04, 0x05, 0xb4,
								0x04, 0x02, 0x08, 0x0a,
								0xbf, 0xb6, 0x00, 0xfa,
								0x00, 0x00, 0x00, 0x00,
								0x01, 0x03, 0x03, 0x07,
							},
						},
						Payload: &RawPack{data: []byte{}},
					},
				},
			},
			want: []byte{
				// ip header
				0x45, 0x00, 0x00, 0x3c,
				0x80, 0x40, 0x40, 0x00,
				0x40, 0x06, 0xa4, 0x79,
				0x0b, 0x00, 0x00, 0x01,
				0x0b, 0x00, 0x00, 0x02,
				// tcp header
				0xbb, 0xf8, 0x00, 0x50,
				0x08, 0xa8, 0x4a, 0x04,
				0x00, 0x00, 0x00, 0x00,
				0xa0, 0x02, 0xfa, 0xf0,
				0x67, 0x67, 0x00, 0x00,
				0x02, 0x04, 0x05, 0xb4,
				0x04, 0x02, 0x08, 0x0a,
				0xbf, 0xb6, 0x00, 0xfa,
				0x00, 0x00, 0x00, 0x00,
				0x01, 0x03, 0x03, 0x07,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.args.pack.Encode()
			assert.Nil(t, err)
			assert.Equal(t, got, tt.want)
		})
	}
}

func TestTempChecksum(t *testing.T) {
	pack := NewIPPack(NewTcpPack(&RawPack{}))
	data := []byte{
		0x45, 0x00, 0x00, 0x3c,
		0x00, 0x00, 0x40, 0x00,
		0x40, 0x06, 0x26, 0xf7,
		0x0a, 0x00, 0x00, 0x02,
		0x0a, 0x00, 0x00, 0x00,
		0x1f, 0x90, 0xb1, 0xae,
		0x4b, 0x00, 0x55, 0x8b,
		0x4b, 0x00, 0x55, 0x8b,
		0xa0, 0x12, 0x04, 0x00,
		0x64, 0xcf, 0x00, 0x00,
		0x02, 0x04, 0x05, 0xb4,
		0x04, 0x02, 0x08, 0x0a,
		0xd3, 0x30, 0xe5, 0x98,
		0x00, 0x00, 0x00, 0x00,
		0x01, 0x03, 0x03, 0x07,
	}
	packet, err := pack.Decode(data)
	assert.Nil(t, err)
	packet.TotalLength = 0
	tcpPack := packet.Payload.(*TcpPack)
	tcpPack.TcpHeader.Checksum = 0
	tcpPack.SetPseudoHeader(packet.IPHeader.SrcIP, packet.IPHeader.DstIP)
	newData, err := packet.Encode()
	assert.Nil(t, err)
	assert.Equal(t, newData, data)
}
